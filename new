#include <iostream>
#include <vector>
#include <string>
// Simple hash function (not cryptographically secure)
std::string simple_hash(const std::string& input) {
    unsigned long hash = 0;
    for (char c : input) {
        hash = (hash * 31) + c;  // Multiply by a prime number for basic hash
    }
    return std::to_string(hash);
}
// Function to create Merkle tree and return the Merkle Root
std::string createMerkleTree(const std::vector<std::string>& transactions) {
    std::vector<std::string> current_level = transactions;
    // Step 1: Loop until only one element is left (Merkle Root)
    while (current_level.size() > 1) {
        std::vector<std::string> next_level;

        // Step 2: Pair adjacent nodes and hash them
        for (size_t i = 0; i < current_level.size(); i += 2) {
            if (i + 1 < current_level.size()) {
                // Pair current node and the next node
                next_level.push_back(simple_hash(current_level[i] + current_level[i + 1]));
            } else {
                // If odd number of nodes, duplicate the last node
                next_level.push_back(simple_hash(current_level[i] + current_level[i]));
            }
        }
        // Move to the next level (created by hashing pairs)
        current_level = next_level;
    }

    // Step 3: Return the Merkle Root (the last remaining hash)
    return current_level[0];
}
int main() {
    // Step 1: Example transactions
    std::vector<std::string> transactions = {
        "Transaction 1",
        "Transaction 2",
        "Transaction 3",
        "Transaction 4"
    };
    // Step 2: Create the Merkle Tree and get the Merkle Root
    std::string merkle_root = createMerkleTree(transactions);
    // Step 3: Output the Merkle Root
    std::cout << "Merkle Root: " << merkle_root << std::endl;
    return 0;
}
